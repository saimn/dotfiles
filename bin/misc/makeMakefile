#! /bin/bash

############################################################################################
# File   : makeMakefile
# Author : Sebastien VARRETTE <Sebastien.Varrette@uni.lu>
#          (Web page : http://www-id.imag.fr/~svarrett/)
# Creation date : 26 Jan 2004
# Last modification: 2 Dec 2008
#
# Description : see the print_help function or launch 'makeMakefile --help'
#  
# This program is free software; you can redistribute it and/or modify it under the terms 
# of the GNU General Public License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
# See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this 
# program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, 
# Fifth Floor, Boston, MA  02110-1301, USA.
# 
# Sebastien Varrette <Sebastien.Varrette@uni.lu> 
# University of Luxembourg 
# 6, rue Richard Coudenhove-Kalergi
# L-1359 Luxembourg, LUXEMBOURG
############################################################################################

### Global variables
VERSION=1.1
COMMAND=`basename $0`
VERBOSE=""
DEBUG=""
SIMULATION=""

### displayed colors
COLOR_GREEN="\033[0;32m"
COLOR_RED="\033[0;31m"
COLOR_YELLOW="\033[0;33m"
COLOR_VIOLET="\033[0;35m"
COLOR_CYAN="\033[0;36m"
COLOR_BOLD="\033[1m"
COLOR_BACK="\033[0m"

### Local variables
DELETE_MODE=""
BEAMER_ADDITIONAL_FILES_TGZ=$HOME/PRESENTATIONS/beamer_additionnal_files.tgz

#######################
### print functions ###
#######################

####
# print version of this program
##
print_version() {
    cat <<EOF
This is $COMMAND version "$VERSION".
Copyright (c) 2008 Sebastien VARRETTE  (http://www-id.imag.fr/~svarrett/)
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
}

####
# print help
##
print_help() {
cat <<EOF
NAME
	$COMMAND -- a script that generates 'generic' Makefile for different
        kind of projects, namely C, C++, Java, LaTeX, beamer and wml.

SYNOPSIS
	$COMMAND [-V | -h]	
	$COMMAND [-v] [-d]
        $COMMAND [-d DIRECTORY] [-r] type	

DESCRIPTION
	The 'generic' aspect means that adding/removing new source files
        in the project directory no longer requires to modify the Makefile 
        as it is the case in general.
        Each project comes with an organization (files/directory) that 
        corresponds to my own style of development. Please note that this 
        organization is assumed in the generated Makefiles.
        the mandatory argument 'type' can take one of the following values: 
           'c'         : create a C project   (n sources/1 executable)
           'multi_c'   : create a C project   (n sources/n executables)
           'cpp'       : create a C++ project (n sources/1 executable)
           'multi_cpp' : create a C++ project (n sources/n executables)
           'java'      : create a Java project 
           'latex'     : create a LaTeX project 
           'beamer'    : create a beamer peresentation
           'wml'       : create a WML project (Website Meta Language) 

OPTIONS
	--debug
		Debug mode. Causes $COMMAND to print debugging messages.
        -d --directory 
                create a directory and put the generated files into it.
	-h --help
		Display a help screen and quit.
        -r --remove
                Remove files/directories created for the project of type 
                project_type
	-s --dry-run
		Simulation mode. 
	-v --verbose
		Verbose mode. 
	-V --version
		Display the version number then quit. 

AUTHOR
	Sebastien VARRETTE <Sebastien.Varrette@uni.lu>
	Web page: http://www-id.imag.fr/~svarrett/ 

REPORTING BUGS 
	Please report bugs to <Sebastien.Varrette@uni.lu>

COPYRIGHT
	This is free software; see the source for copying conditions.  There is NO
	warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
       
SEE ALSO	
	Other scripts are available on my web site http://www-id.imag.fr/~svarrett/
EOF
}

######
# Print information in the following form: '[$2] $1' ($2=INFO if not submitted)
# usage: info text [title]
##
info() {
    [ -z "$1" ] && print_error_and_exit "[$FUNCNAME] missing text argument"
    local text=$1
    local title=$2
    # add default title if not submitted but don't print anything 
    [ -n "$text" ] && text="${title:==>} $text"    
    echo -e $text
}
debug()   { [ -n "${DEBUG}"   ] && info "$1" "[${COLOR_YELLOW}DEBUG${COLOR_BACK}]"; }
verbose() { [ -n "${VERBOSE}" ] && info "$1"; }
error()   { info "$1" "[${COLOR_RED}ERROR${COLOR_BACK}]"; }
warning() { info "$1" "[${COLOR_VIOLET}WARNING${COLOR_BACK}]"; }
print_error_and_exit() {
    local text=$1
    [ -z "$1" ] && text=" Bad format"
    error  "$text. '$COMMAND -h' for help."
    exit 1
}
#####
# print the strings [ OK ] or [ FAILED ] or [ FAILED ]\n$1
##
print_ok()     { echo -e "[   ${COLOR_GREEN}OK${COLOR_BACK}   ]"; }
print_failed() { echo -e "[ ${COLOR_RED}FAILED${COLOR_BACK} ]"; }
print_failed_and_exit() { 
    print_failed
    [ ! -z "$1" ] && echo "$1"
    exit 1
}

#########################
### toolbox functions ###
#########################

#####
# execute a local command 
# usage: execute command
###
execute() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] missing command argument"
    debug "[$FUNCNAME] $*"
    [ -n "${SIMULATION}" ] && echo -e "\n(simulation) $*" || eval $*
    local exit_status=$?
    debug "[$FUNCNAME] exit status: $exit_status"
    return $exit_status
}

####
# ask to continue. exit 1 if the answer is no
# usage: really_continue text
##
really_continue() {
    echo -e -n "[${COLOR_VIOLET}WARNING${COLOR_BACK}] $1 Are you sure you want to continue? [Y|n] "
    read ans
    case $ans in 
	n*|N*) exit 1;;
    esac
}

###
# check if files exists. If a single file exist
# usage: check_for_overwrite file1 file2 etc.
##
check_for_overwrite() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] missing argument"
    for f in $*; do 
	[ -f $f ] && really_continue "You are about to overwrite $f.";
    done
}

################################################################################
################################################################################
###
# Create a Makefile header
# if $1 is present, there is no check for overwrite.
##
createMakefileHeader() {
    [ -z "$1" ] && check_for_overwrite Makefile
    cat > Makefile << "EOF"
####################################################################################
# Makefile (configuration file for GNU make - see http://www.gnu.org/software/make/)
#
# --------------------------------------------------------------------------------
# This is a generic makefile in the sense that it doesn't require to be 
# modified when adding/removing new source files.
# --------------------------------------------------------------------------------
#
# Author: Sebastien Varrette <Sebastien.Varrette@uni.lu>
#          Web page : http://www-id.imag.fr/~svarrett/
EOF
    echo "# Version : ${VERSION}" >> Makefile
    echo "# Creation date : `date '+%F'`"   >> Makefile
    echo "#" >> Makefile
}

###
# Create README header
##
createREADMEHeader() {
    check_for_overwrite README
    cat > README << "EOF"
README  
Author : Sebastien Varrette <Sebastien.Varrette@uni.lu>
         Web page : http://www-id.imag.fr/~svarrett/

Source version : 0.1

EOF
}

###
# Create a Makefile for a subdirectory that call the Makefile in the parent dir 
# usage: createMakefileInSubdir [parentdir]
##
createMakefileInSubdir() {
    local parentdir=""
    [ $# -ne 0 ] && parentdir=$1
    if [ -n "${SIMULATION}" ];  then 
	echo "(simulation) create $parentdir/Makefile suited for sub directories"
	return 
    fi
    createMakefileHeader "nocheck"
    cat >> Makefile << "EOF"
# Please refer to ../Makefile for more informations on compilation options
# Alternatively, you may try 'make help'
# 
all:
	make -C ../

%:
	make -C ../ \$@

EOF
}

###
# proceed with additionnal files present in a tgz aarchive to be uncompressed in 
# the current directory
# usage: proceedAdditionnalFiles file.tgz
##
proceedAdditionnalFiles() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] missing argument"
    local file=$1
    if [ -f $file ]; then 
	really_continue "you have the possibility to add other files from the archive $file";
	tar xvzf $file
    else
	error "$file not found";
    fi
}

################################################################################
#                                     LaTeX                                    #
################################################################################

###
# Create a Makefile for a LaTeX project
##
createMakefileFor_latex() {
    createMakefileHeader
    cat >> Makefile << "EOF"
# Compilation of files written in LaTeX
#
# This makefile search for LaTeX sources from the current directory, identifies 
# the main files (i.e the one containing the sequence '\begin{document}') and 
# launch the compilation for the generation of PDFs and optionnaly compressed 
# Postscript files. 
# Two compilation modes can be configured using the USE_PDFLATEX variable:
#    1/ Rely on pdflatex to generate directly a pdfs from the LaTeX sources. 
#       The compilation follow then the scheme: 
#
#                main.tex --[pdflatex/bibtex]--> main.pdf + main.[aux|log etc.]
#
#       Note that in that case, your figures should be in pdf format instead of eps.
#       To use this mode, just set the USE_PDFLATEX variable to 'yes'
# 
#    2/ Respect the classical scheme:                             +-[dvips]-> main.ps
#                                                                 |             |             
#                                                                 |        +-[gzip]
#       main.tex -[latex/bibtex]-> main.dvi + main.[aux|log etc.]-+        |     
#                                                                 |        +-> main.ps.gz     
#                                                                 +-[dvipdf]-> main.pdf
#       To use this mode, just set the USE_PDFLATEX variable to 'no'
# In all cases: 
#   - all the intermediate files (main.aux, main.log etc.) will be moved
#     to $(TRASH_DIR)/ (if it exists). 
#   - the dvi file (generated if pdflatex is not used) will stay in the current directory.  
#   - other target files (pdfs + compressed Postscript files if pdflatex is not used)
#     are moved to the $(OUTPUT_DIR) directory. 
#     Note that this directory is automatically created if $(OUTPUT_DIR) differs from '.'
#
# Available Commands  
# ------------------
# make       : Compile LaTeX files, generated files (pdf etc.) are placed in $(OUTPUT_DIR)/ 
# make force : Force re-compilation, even if not needed 
# make clean : Remove all generated files 
# make html  : generate HTML files from tex in $(HTML_DIR)/ (using latex2html)
#                  The directory is created on the first invocation
# make help      : print help message 
#
############################## Variables Declarations ##############################

# set to 'yes' to use pdflatex for the direct generation of pdf from LaTeX sources
# set to 'no' to use the classical scheme tex -> dvi -> [ps|pdf] by dvips
USE_PDFLATEX = yes

# Directory where PDF, Postcript files and other generated files will be placed
OUTPUT_DIR = Output
TRASH_DIR  = .Trash
HTML_DIR   = $(OUTPUT_DIR)/HTML
# Check avalibility of source files
TEX_SRC    = $(wildcard *.tex)
ifeq ($(TEX_SRC),)
all:
	@echo "No source files available - I can't handle the compilation"
	@echo "Please check the presence of source files (with .tex extension)"
else
# Main tex file and figures it may depend on 
MAIN_TEX   = $(shell grep -l "[\]begin{document}" $(TEX_SRC) | xargs echo)
FIGURES    = $(shell find . -name "*.eps" -o -name "*.fig" | xargs echo)
ifeq ($(MAIN_TEX),)
all:
	@echo "I can't find any .tex file with a '\begin{document}' directive "\
		"among $(TEX_SRC). Please define a main tex file!"
else
# Commands used during compilation
LATEX      = $(shell which latex)
PDFLATEX   = $(shell which pdflatex)
LATEX2HTML = $(shell which latex2html)
BIBTEX     = $(shell which bibtex)
DVIPS      = $(shell which dvips)
DVIPDF     = $(shell which dvipdf)
GZIP       = $(shell which gzip)
# Generated files
DVI    	     = $(MAIN_TEX:%.tex=%.dvi)
PS           = $(MAIN_TEX:%.tex=%.ps)
PS_GZ        = $(MAIN_TEX:%.tex=%.ps.gz)
PDF          = $(MAIN_TEX:%.tex=%.pdf)
OUTPUT_PS_GZ = $(PS_GZ:%=$(OUTPUT_DIR)/%)
OUTPUT_PDF   = $(PDF:%=$(OUTPUT_DIR)/%)
BACKUP_FILES = $(shell find . -name "*~")
# Files to move to $(TRASH_DIR) after compilation
# Never add *.tex (or any reference to source files) for this variable.
TO_MOVE      = *.aux *.log *.toc *.lof *.lot *.bbl *.blg 

############################### Now starting rules ################################
# Required rule : what's to be done each time 
all: $(OUTPUT_PDF)

# Dvi files generation
dvi $(DVI) : $(TEX_SRC) $(FIGURES)
	@echo "==> Now generating $(DVI)"
	@for f in $(MAIN_TEX); do                                    \
	   $(LATEX) $$f;                                             \
	   bib=`grep "^[\]bibliography{" $$f|sed -e "s/^[\]bibliography{\(.*\)}/\1/"|tr "," " "`;\
	   if [ ! -z "$$bib" ]; then                                 \
	  	echo "==> Now running BibTeX ($$bib used in $$f)";   \
		$(BIBTEX) `basename $$f .tex`;                       \
		$(LATEX) $$f;                                        \
	   fi;                                                       \
	   $(LATEX) $$f;                                             \
	   $(MAKE) move_to_trash;                                    \
	done
	@echo "==> $(DVI) generated"

# Compressed Postscript generation 
ps $(PS) $(OUTPUT_PS_GZ) : $(DVI)
	@for dvi in $(DVI); do                                \
	   	ps=`basename $$dvi .dvi`.ps;                  \
	   	echo "==> Now generating $$ps.gz from $$dvi"; \
	  	$(DVIPS) -q -o $$ps $$dvi;                    \
	   	$(GZIP) -f $$ps;                              \
	done
	@if [ "$(OUTPUT_DIR)" != "." ]; then                        \
		$(MAKE) create_output_dir;                           \
		for ps in $(PS); do                                 \
			echo "==> Now moving $$ps.gz to $(OUTPUT_DIR)/"; \
			mv $$ps.gz $(OUTPUT_DIR);                   \
		done;                                               \
	fi

###################### The following part is specific for the case where pdflatex is used ######################
ifeq ("$(USE_PDFLATEX)", "yes")
pdflatex $(OUTPUT_PDF) $(PDF): $(TEX_SRC) $(FIGURES)
	@echo "==> Now generating $(PDF)"
	@for f in $(MAIN_TEX); do                                    \
	   $(PDFLATEX) $$f;                                             \
	   bib=`grep "^[\]bibliography{" $$f|sed -e "s/^[\]bibliography{\(.*\)}/\1/"|tr "," " "`;\
	   if [ ! -z "$$bib" ]; then                                 \
	  	echo "==> Now running BibTeX ($$bib used in $$f)";   \
		$(BIBTEX) `basename $$f .tex`;                       \
		$(PDFLATEX) $$f;                                             \
	   fi;                                                       \
	   $(PDFLATEX) $$f;                                          \
	   $(MAKE) move_to_trash;                                    \
	done
	@if [ "$(OUTPUT_DIR)" != "." ]; then                         \
		$(MAKE) create_output_dir;                           \
		for pdf in $(PDF); do                                \
			echo "==> Now moving $$pdf to $(OUTPUT_DIR)/"; \
			mv $$pdf $(OUTPUT_DIR);                      \
		done;                                                \
	fi
	@$(MAKE) help

###################### End of specific case where pdflatex is used ######################
else 
pdf $(OUTPUT_PDF) $(PDF): $(OUTPUT_PS_GZ)
	@for dvi in $(DVI); do                                \
	   	ps=`basename $$dvi .dvi`.pdf;                 \
	   	echo "==> Now generating $$pdf from $$dvi";   \
	  	$(DVIPDF) $$dvi;                              \
	done
	$(MAKE) create_output_dir           	     
	@if [ "$(OUTPUT_DIR)" != "." ]; then                             \
		for pdf in $(PDF); do                                    \
			echo "==> Now moving $$pdf to $(OUTPUT_DIR)/";   \
			mv $$pdf $(OUTPUT_DIR);                          \
		done;                                                    \
	fi
	@$(MAKE) help
endif
###################### End of specific case where pdflatex is NOT used ######################

TO_TRASH=$(shell ls $(TO_MOVE) 2>/dev/null | xargs echo)
move_to_trash:
	@if [ ! -z "${TO_TRASH}" -a -d $(TRASH_DIR) ]; then              \
                echo "==> Now moving ${TO_TRASH} to $(TRASH_DIR)/";      \
                mv -f ${TO_TRASH} $(TRASH_DIR)/;                         \
        elif [ ! -d $(TRASH_DIR) ]; then                             \
                echo "*** /!\ $(TRASH_DIR)/ does not exist!!!";      \
                echo "***     May be you should create it to hide the files ${TO_TRASH}";\
        fi;   

create_output_dir: 
	@if [ ! -d $(OUTPUT_DIR) ]; then                                                  \
		echo "    /!\ $(OUTPUT_DIR)/ does not exist ==> Now creating ./$(OUTPUT_DIR)/"; \
		mkdir -p ./$(OUTPUT_DIR);                                                 \
	fi;  


# Clean option
clean:
	rm -f *.dvi $(TO_MOVE) $(BACKUP_FILES)
	@if [ ! -z "$(OUTPUT_DIR)" -a -d $(OUTPUT_DIR)  -a "$(OUTPUT_DIR)" != "." ]; then       \
	   for f in $(MAIN_TEX); do                                  \
		base=`basename $$f .tex`;                            \
		echo "==> Now cleaning $(OUTPUT_DIR)/$$base*";       \
		rm -rf $(OUTPUT_DIR)/$$base*;                        \
           done                                                      \
	fi
	@if [ ! -z "$(TRASH_DIR)" -a -d $(TRASH_DIR) ];   then       \
	   for f in $(MAIN_TEX); do                                  \
		base=`basename $$f .tex`;                            \
		echo "==> Now cleaning $(TRASH_DIR)/$$base*";        \
		rm -rf $(TRASH_DIR)/$$base*;                         \
	   done                                                      \
	fi
	@if [ ! -z "$(HTML_DIR)" -a -d $(HTML_DIR) -a "$(HTML_DIR)" != "." ]; then       \
	   echo "==> Now removing $(HTML_DIR)";                      \
	   rm  -rf $(HTML_DIR);                                      \
	fi

# force recompilation
force :
	@touch $(MAIN_TEX)
	@$(MAKE)

# Test values of variables - for debug purpose  
test:
	@echo "--- Directories --- "
	@echo "OUTPUT_DIR -> $(OUTPUT_DIR)"
	@echo "TRASH_DIR  -> $(TRASH_DIR)"
	@echo "HTML_DIR   -> $(HTML_DIR)"
	@echo "--- Compilation commands --- "
	@echo "PDFLATEX   -> $(PDFLATEX)"
	@echo "LATEX      -> $(LATEX)"
	@echo "LATEX2HTML -> $(LATEX2HTML)"
	@echo "BIBTEX     -> $(BIBTEX)"
	@echo "DVIPS      -> $(DVIPS)"
	@echo "DVIPDF     -> $(DVIPDF)"
	@echo "GZIP       -> $(GZIP)"
	@echo "--- Files --- "
	@echo "TEX_SRC    -> $(TEX_SRC)"
	@echo "MAIN_TEX   -> $(MAIN_TEX)"
	@echo "FIGURES    -> $(FIGURES)"
	@echo "BIB_FILES  -> $(BIB_FILES)"
	@echo "DVI        -> $(DVI)"
	@echo "PS         -> $(PS)"
	@echo "PS_GZ      -> $(PS_GZ)"
	@echo "PDF        -> $(PDF)"
	@echo "TO_MOVE    -> $(TO_MOVE)"
	@echo "OUTPUT_PS_GZ -> $(OUTPUT_PS_GZ)"
	@echo "OUTPUT_PDF   -> $(OUTPUT_PDF)"
	@echo "BACKUP_FILES -> $(BACKUP_FILES)"

# print help message
help :
	@echo '+---------------------------------------------------------------+'
	@echo '|                        Available Commands                     |'
	@echo '+------------+--------------------------------------------------+'
	@echo '| make       | Compile LaTeX files.                             |'
	@echo '|            | Generated files (pdf etc.) are placed in $(OUTPUT_DIR)/ |'
	@echo '| make force | Force re-compilation, even if not needed         |'
	@echo '| make clean | Remove all generated files                       |'
	@echo '| make html  | Generate HTML files from TeX in $(HTML_DIR)/     |'
	@echo '| make help  | Print help message                               |'
	@echo '+------------+--------------------------------------------------+'


# HTML pages generation using latex2html
# First check that $(LATEX2HTML) and $(HTML_DIR)/ exist
html :
ifeq ($(LATEX2HTML),)
	@echo "Please install latex2html to use this option!"
	@echo "('apt-get install latex2html' under Debian)"
else
	@if [ ! -d ./$(HTML_DIR) ]; then                                    \
	   echo "$(HTML_DIR)/ does not exist => Now creating $(HTML_DIR)/"; \
	   mkdir -p ./$(HTML_DIR);                                          \
	fi
	-cp $(TRASH_DIR)/*.aux $(TRASH_DIR)/*.bbl .
	$(LATEX2HTML) -show_section_numbers -local_icons -split +1 \
		-dir $(HTML_DIR) $(MAIN_TEX)
	@rm -f *.aux *.bbl $(HTML_DIR)/*.tex $(HTML_DIR)/*.aux $(HTML_DIR)/*.bbl
	@echo "==> HTML files generated in $(HTML_DIR)/" 
	@echo "May be you can try to execute 'mozilla ./$(HTML_DIR)/index.html'"
endif
endif
endif
EOF
}

###
# Create README file for a LaTeX project
##
createREADMEFor_latex() {
    createREADMEHeader
    cat >> README <<EOF
---------------
 Prerequisite 
---------------

Compilation of the files contained in this directory requires the
following binaries : 
- latex and pdflatex 	 (for compilation)
- bibtex 	         (for bibliography/references)
- dvips         	 (conversion dvi <-> ps)
- gzip 		         (compression)
- dvipdf        	 (conversion dvi <-> pdf) 
- [optionnal] latex2html (html generation from LaTeX)
Please check that these commands are available on your system. 

This LaTeX document can be compiled using the GNU Make utility.
Documentation on the Make utility may be found at 
              http://www.gnu.org/software/make/manual/make.html  
---------
 Install
---------

Just type 'make' in a terminal. 
Generated files (PDF and optionaly a compressed Postscript) will be placed in the
Output/ directory. Other intermediate files will be place in .Trash/ directory.

You have the possiblity to generate HTML files from the LaTeX sources
To do so, simply run 'make html', generated files will be located in Output/HTML/. 
Please note that this directory is only created when summoning 'make html' and 
it will be deleted on 'make clean' 

-----------
 Uninstall
-----------
Just run 'make clean'

------------------
 Compilation mode
------------------

Two compilation modes can be configured using the USE_PDFLATEX variable of the Makefile:
    1/ Rely on pdflatex to generate directly a pdfs from the LaTeX sources. 
       The compilation follow then the scheme: 
                file.tex --[pdflatex/bibtex]--> file.pdf + file.[aux|log etc.]

       Note that in that case, your figures should be in pdf format instead of eps.
       To use this mode, just set the USE_PDFLATEX variable to 'yes'
 
    2/ Respect the classical scheme:                             +-[dvips]-> file.ps
                                                                 |             |             
                                                                 |        +-[gzip]
       file.tex -[latex/bibtex]-> file.dvi + file.[aux|log etc.]-+        |     
                                                                 |        +-> file.ps.gz     
                                                                 +-[dvipdf]-> file.pdf
       To use this mode, just set the USE_PDFLATEX variable to 'no'
 In all cases: 
   - all the intermediate files (file.aux, file.log etc.) will be moved
     to .Trash (if it exists). 
   - the dvi file (generated if pdflatex is not used) will stay in the current directory.  
   - other target files (pdfs + compressed Postscript files if pdflatex is not used)
     are moved to the Output/ directory. 
     Note that this directory is automatically created.

--------------------
 Detailled Commands 
--------------------

 make       : Compile LaTeX files, generated files (pdf etc.) are placed in Output/ 
 make force : Force re-compilation, even if not needed 
 make clean : Remove all generated files 
 make html  : generate HTML files from tex in Output/HTML/ (using latex2html)
                  The directory is created on the first invocation
 make help  : print help message 

-------------------------------------------------------------
 Using a Versioning System such as CVS/Subversion/Cogito/GIT 
-------------------------------------------------------------

Very often, several authors contributes to documents written in LaTeX (this is the case 
typically with scientific publications).
In that case, the use of a versionning system is a good idea.
There exists several such systems, here are links to web site that explain the basic 
commands of each of them.

 -  CVS: 
      http://ximbiot.com/cvs/cvshome/docs/blandy.html
      http://www.idealx.org/doc/cvs.fr.html 
      http://freealter.org/doc_distrib/cvs-1.11/introduction/cvs-4.html

 - Subversion: 
      http://svnbook.red-bean.com/
      http://helpdesk.gforge.uni.lu/svn.html

 - Cogito/GIT
      http://www.kernel.org/pub/software/scm/cogito/README
      http://linux.yyz.us/git-howto.html
      http://www.rockfloat.com/howto/git.html
EOF
}

###
# Create a Makefile for a LaTeX project
##
createMakefileFor_beamer() {
    createMakefileHeader
    cat >> Makefile << "EOF"
# Compilation of beamer presentations (version 0.2)
# beamer is a special package of LaTeX to realize  presentations (as powerpoint). 
# More informations on http://latex-beamer.sourceforge.net/
#       (Debian package for beamer : latex-beamer)
#
# Available Commands  
# ------------------
# make           : Compile tex files, the generated pdf is placed in current dir  
# make force     : Force the complete re-compilation, even if not needed 
# make clean     : Remove generated files           
# make help      : print help message                                          
############################# Variables Declarations ##############################
# Main tex file and figures it may depend on 
MAIN    = $(shell grep -l "[\]begin{document}" *.tex | xargs echo)
ALLTEX  = $(wildcard *.tex)
FIGURES = $(shell find . -name "*.eps" -o -name "*.fig")
# Compilation Command ;
PDFLATEX   = $(shell which pdflatex)
# generated files
PDF     = $(MAIN:%.tex=%.pdf)
AUX     = $(MAIN:%.tex=%.aux)
LOG     = $(MAIN:%.tex=%.log)
NAV     = $(MAIN:%.tex=%.nav)
OUT     = $(MAIN:%.tex=%.out)
SNM     = $(MAIN:%.tex=%.snm)
TOC     = $(MAIN:%.tex=%.toc)
# backup files generated by text editor like emacs or vi
BACKUP_FILES   = $(shell find . -name "*~")
############################### Now starting rules ################################
# Check avalibility of pdflatex
ifeq ($(PDFLATEX),)
all:
	@echo "I can't find pdflatex on your system. Please install it first"
	@echo "(the Debian package tetex-bin should provide it)"
else
# Check avalibility of source file
ifeq ($(MAIN),)
all:
	@echo "No source files available - I can't handle the compilation"
	@echo "Please check the presence of at least a tex files containing "\
		"the '\begin{document}' directive"
else
all: $(PDF)

test:
	@echo "MAIN     -> $(MAIN)"
	@echo "ALLTEX   -> $(ALLTEX)"
	@echo "PDF      -> $(PDF)"
	@echo "FIGURES  -> $(FIGURES)"
	@echo "PDFLATEX -> $(PDFLATEX)"
	@echo "AUX      -> $(AUX)"
	@echo "LOG      -> $(LOG)"
	@echo "NAV      -> $(NAV)"
	@echo "OUT      -> $(OUT)"
	@echo "SNM      -> $(SNM)"
	@echo "TOC      -> $(TOC)"
	@echo "BACKUP_FILES -> $(BACKUP_FILES)"

quick: $(ALLTEX) $(FIGURES)
	@ for f in $(MAIN) ; \
	do echo -e "\n"; \
	   echo -e "      *************************************"; \
	   echo -e "      *** QUICK Proceeding $$f "; \
	   echo -e "      *************************************\n"; \
	   $(PDFLATEX) $$f ; \
	done
	rm -f $(AUX) $(LOG) $(NAV) $(OUT) $(SNM) $(TOC)


$(PDF) : $(ALLTEX) $(FIGURES)
	@ for f in $(MAIN) ; \
	do echo -e "\n"; \
	   echo -e "      *************************************"; \
	   echo -e "      *** Proceeding $$f "; \
	   echo -e "      *************************************\n"; \
	   $(PDFLATEX) $$f ; \
	   $(PDFLATEX) $$f ; \
	done
	rm -f $(AUX) $(LOG) $(NAV) $(OUT) $(SNM) $(TOC)
	$(MAKE) help

clean :
	@echo "=> Delete all generated files"
	@rm -f $(AUX) *.aux $(LOG) $(NAV) $(OUT) $(SNM) $(TOC) $(PDF)
	@echo "=> Delete backup files generated by Emacs or Vim"
	@rm -f $(BACKUP_FILES)

force:
	touch $(MAIN)
	$(MAKE)

help :
	@echo '+------------------------------------------------------------------+'
	@echo '|                        Available Commands                        |'
	@echo '+------------+-----------------------------------------------------+'
	@echo '| make       | Compile tex files, the pdf is placed in current dir |'
	@echo '| make force | Force re-compilation, even if not required          |'
	@echo '| make clean | Remove generated files.                             |'
	@echo '| make help  | Print help message                                  |'
	@echo '+------------+-----------------------------------------------------+'
endif
endif
EOF
}
createREADMEFor_beamer() {
    createREADMEHeader
    cat >> README <<EOF
This is a beamer presentation. Beamer (http://latex-beamer.sourceforge.net/) is
a special package for LaTeX to handle slides generation (as powerpoint).
First ensure that you have installed this package on your system 
('apt-get install latex-beamer' under Debian).

---------
 Install
---------
Just type 'make' in a terminal. 
The makefile supposes the availability of 'pdflatex'. Please make sure 
it is also installed on your system. 

Finally, compilation is achieved by typing 'make'. 

-----------
 Uninstall
-----------
Just run 'make clean'


Available Commands  
------------------
 make           : Compile tex files, the generated pdf is placed in current dir  
 make force     : Force the complete re-compilation, even if not needed 
 make clean     : Remove generated files           
 make help      : print help message                 
EOF
}

################################################################################
#                                     C / C++                                  #
################################################################################

###
# Create a Makefile for C or C++ project 
##
createMakefileFor_c_cpp() {
    createMakefileHeader
    cat >> Makefile << "EOF"
# Compilation of files written in C/C++
# 
# Available Commands  
# ------------------
# make           : Compile files, binary is generated in the current directory  
# make force     : Force the complete re-compilation, even if not needed 
# make clean     : Remove backup files (*~) and other generated files        
# make doc       : Generate Doxygen documentation (in Doc/) see www.doxygen.org 
# make help      : print help message                                          
#
############################## Variables Declarations ##############################
# Name of the executable to generate --- TO BE ADAPTED ---
EXE          = toto 
# Directory where header files (.h) and object files (.o) will be placed
INCLUDE_DIR  = .
OBJ_DIR      = .obj
# File entensions for C, C++ and header files
C_EXT        = c
CPP_EXT      = cpp
H_EXT        = h
# Source files
SRC          = $(wildcard *.$(C_EXT) *.$(CPP_EXT))
SRC_H        = $(wildcard *.$(H_EXT) $(INCLUDE_DIR)/*.$(H_EXT))
ALL_SRC      = $(SRC) $(SRC_H)
# Check avalibility of source files
ifeq ($(SRC),)
all:
	@echo "No source files available - I can't handle the compilation"
	@echo "Please check the presence and/or extension of source files "
	@echo "(This makefile is configured to manage *.$(C_EXT) or *.$(CPP_EXT) - "\
		"you may modify variables C_EXT and CPP_EXT to reflect your " \
		"own programming style)"
else
# Object files
OBJ          = $(patsubst %.$(C_EXT),%.o,$(SRC:.$(CPP_EXT)=.o))
ABSOBJ       = $(OBJ:%.o=$(OBJ_DIR)/%.o)
# Backup files generated by text editors
BACKUP_FILE  = $(shell find . -name "*~")
# Doxygen stuff 
DOC_DIR      = Doc
DOXYGEN      = $(shell which doxygen)
DOXYGEN_CONF = .doxygen.conf
YES_ATTRIBUTES := JAVADOC_AUTOBRIEF EXTRACT_ALL EXTRACT_PRIVATE EXTRACT_STATIC \
		 SOURCE_BROWSER GENERATE_MAN 

# Compilator configuration
# Detect if you have a C or a C++ project through file extension
ifneq ($(filter %.c,$(SRC)),)
	CXX    = gcc
	YES_ATTRIBUTES := $(YES_ATTRIBUTES) OPTIMIZE_OUTPUT_FOR_C
else 
	CXX    = g++
	CXXFLAGS += "-Wno-deprecated "
endif

CXXFLAGS     += -g3 -O3 -Wall -I$(INCLUDE_DIR) -c
LDFLAGS      = 

# Specifies the list of directories that make should search
VPATH        = $(INCLUDE_DIR):$(OBJ_DIR)
# dependance file used for make rules 
MAKEDEP_FILE = .Makefile.dep

############################### Now starting rules ################################
# Required rule : what's to be done each time 
all :  	$(MAKEDEP_FILE) $(EXE) 

# Generate TAGS for emacs
TAGS : $(ALL_SRC)
	etags $<
	cp TAGS $(INCLUDE_DIR)/

# Clean Options
clean : 
	@echo "=> remove backup files generated by emacs and vi $(BACKUP_FILE)"
	@rm -f $(BACKUP_FILE)
# Clean everything (including object files, binaries and documentation) 
# distclean : clean 
	@echo "=> removing object files $(ABSOBJ) and  generated executable $(EXE)"
	@rm -f $(ABSOBJ) $(EXE)
	@if [ ! -z "$(DOC_DIR)" -a ! -z "$(DOXYGEN)" ]; then \
		echo "=> removing documentation ('make doc' to regenerate it)"; \
		rm -rf $(DOC_DIR)/*; \
	fi
	@echo "=> removing $(MAKEDEP_FILE)"
	@rm -f $(MAKEDEP_FILE)

# Force re-compilation, even if not required 
force :
	touch $(ALL_SRC) $(ABSOBJ)
	@$(MAKE)

# Generate the dependance file
$(MAKEDEP_FILE) : $(ALL_SRC) 
	$(CXX) $(SPECIAL_CPP_OPTION) -MM -I$(INCLUDE_DIR) $(SRC) > $@

include $(MAKEDEP_FILE)

# Generic description for compilation of object files 
%.o : %.$(C_EXT)
	$(CXX) $(CXXFLAGS) $< -o $(OBJ_DIR)/$@ 
%.o : %.$(CPP_EXT)
	$(CXX) $(CXXFLAGS) $< -o $(OBJ_DIR)/$@ 

# Generation of the final binary (see $(EXE))
$(EXE) : $(OBJ) $(ALL_SRC)
	$(CXX) -g -o $@ $(ABSOBJ) $(LDFLAGS)
	@$(MAKE) help

# Help rule - print help message
help :
	@echo '+-----------------------------------------------------------------------------+'
	@echo '|                             Available Commands                              |'
	@echo '+----------------+------------------------------------------------------------+'
	@echo '| make           | Compile files, binary is generated in the current directory|'
	@echo '| make force     | Force the complete re-compilation, even if not required    |'
	@echo '| make clean     | Remove cache backup files generated by emacs and vi        |'
	@echo '| make distclean | Remove all generated files (including .o and binary)       |'
	@echo '| make doc       | Generate documentation using doxygen (see www.doxygen.org) |'
	@echo '| make help      | Print help message                                         |'
	@echo '+----------------+------------------------------------------------------------+'

# Test values of variables - for debug purpose 
test : 
	@echo "INCLUDE_DIR  = $(INCLUDE_DIR)"
	@echo "OBJ_DIR      = $(OBJ_DIR)"
	@echo "EXE          = $(EXE)"
	@echo "SRC          = $(SRC)"
	@echo "SRC_H        = $(SRC_H)"
	@echo "ALL_SRC      = $(ALL_SRC)"
	@echo "OBJ          = $(OBJ)"
	@echo "BACKUP_FILE  = $(BACKUP_FILE)"
	@echo "CXX          = $(CXX)"
	@echo "CXXFLAGS     = $(CXXFLAGS)"
	@echo "ADD_OPT      = $(ADD_OPT)"
	@echo "DOC_DIR      = $(DOC_DIR)"
	@echo "DOXYGEN      = $(DOXYGEN)"
	@echo "DOXYGEN_CONF = $(DOXYGEN_CONF)"
	@echo "YES_ATTRIBUTES = $(YES_ATTRIBUTES)"
	@echo "MAKEDEP_FILE = $(MAKEDEP_FILE)"

# Documentation generation through doxygen 
# First check if the $(DOXYGEN) and the $(DOC_DIR) directory exist
# Then Check $(DOXYGEN_CONF) availability;otherwise,generate one with 'doxygen -s -g'
#    The following attributes should be modified in the generated file: 
#    - OUTPUT_DIRECTORY should be set to '$(DOC_DIR)', INPUT to '. $(INCLUDE_DIR)'
#    - $(YES_ATTRIBUTES) attributes should be set to YES
#    - OPTIMIZE_OUTPUT_FOR_C should be set to YES if the project in in C
# Finally, launch documentation generation
doc :
ifeq ($(DOXYGEN),)
	@echo "Please install Doxygen to use this option!"
	@echo "('apt-get install doxygen' under Debian)"
else
	@if [ ! -d ./$(DOC_DIR) ]; then \
	   echo "$(DOC_DIR)/ does not exist => creating $(DOC_DIR)/"; \
	   mkdir -p ./$(DOC_DIR)/; \
	fi
	@if [ ! -f $(DOXYGEN_CONF) ]; then \
	   echo "I don't found the configuration file for Doxygen($(DOXYGEN_CONF))";\
	   echo "Now generating one using '$(DOXYGEN) -s -g $(DOXYGEN_CONF)'"; \
	   $(DOXYGEN) -s -g $(DOXYGEN_CONF); \
	   echo "Now updating OUTPUT_DIRECTORY attribute to '$(DOC_DIR)'"; \
	   cat $(DOXYGEN_CONF) | sed -e "s/^\(OUTPUT_DIRECTORY \+= \+\).*/\1$(DOC_DIR)/"\
	     > $(DOXYGEN_CONF); \
	   echo "Now updating INPUT attribute to '. $(INCLUDE_DIR)'"; \
	   cat $(DOXYGEN_CONF) | sed -e "s/^\(INPUT \+= \+\).*/\1. $(INCLUDE_DIR)/" \
	     > $(DOXYGEN_CONF); \
	   for attr in $(YES_ATTRIBUTES); do \
		echo "now updating $$attr to YES"; \
		cat $(DOXYGEN_CONF) | sed -e "s/^\($$attr \+= \+\).*/\1YES/" \
		  > $(DOXYGEN_CONF); \
	   done; \
	fi
	$(DOXYGEN) $(DOXYGEN_CONF)
	@echo 
	@echo Documentation generated in $(DOC_DIR)/ 
	@echo May be you can try to execute 'mozilla ./$(DOC_DIR)/html/index.html'
endif
endif
EOF
}
###
# Create a Makefile for C project 
##
createMakefileFor_multi_c() {
    createMakefileHeader
    cat >> Makefile << "EOF"
# Compilation of files written in C/C++
#  each source file is assumed to generate an executable
# 
# Available Commands  
# ------------------
# make           : Compile files, binaries are generated in the current directory  
# make force     : Force the complete re-compilation, even if not needed 
# make clean     : Remove backup files (*~) and other generated files        
#
############################## Variables Declarations ##############################

CC      = gcc
CFLAGS  = -Wall -g3
LDFLAGS =
 
SRC = $(wildcard *.c)
TARGET = $(SRC:.c=)

all: $(TARGET)

force:
	touch $(SRC)
	@$(MAKE)

clean: 
	@echo "=> remove binaries and backup files generated by emacs/vi"
	@rm -f $(TARGET) *~

EOF
}

###
# Create a Makefile for C++ project 
##
createMakefileFor_multi_cpp() {
    createMakefileHeader
    cat >> Makefile << "EOF"
# Compilation of files written in C++
#  each source file is assumed to generate an executable
# 
# Available Commands  
# ------------------
# make           : Compile files, binaries are generated in the current directory  
# make force     : Force the complete re-compilation, even if not needed 
# make clean     : Remove backup files (*~) and other generated files        
#
############################## Variables Declarations ##############################

CXX      = g++
CXXFLAGS = -Wall -g3
LDFLAGS  =

SRC = $(wildcard *.cpp)
TARGET = $(SRC:.cpp=)

all: $(TARGET)

force:
	touch $(SRC)
	@$(MAKE)

clean: 
	@echo "=> remove binaries and backup files generated by emacs/vi"
	@rm -f $(TARGET) *~

EOF
}
###
# Create README file for a C/C++ project
##
createREADMEFor_c_cpp() {
    createREADMEHeader
    cat >> README <<EOF
---------------
 Prerequisite 
---------------

Compilation of the files contained in this directory require the
following binaries : 
- gcc 	 (for compilation)
- [optionnal] doxygen (for automatic doc generation from sources)
Please check that these commands are available on your system. 

This program  can be compiled using the GNU Make utility.
Documentation on the Make utility may be found at 
              http://www.gnu.org/software/make/manual/make.html  
---------
 Install
---------

Just type 'make' in a terminal. 
The binary generated will be placed in the current directory 
(the name of the generated file can be changed through the EXE variable of 
the Makefile).

Object files will be placed in .obj/

-----------
 Uninstall
-----------
Just run 'make clean

--------------------
 Detailled Commands 
--------------------

 make           : Compile files, binary is placed in the current directory
 make force     : Force the complete re-compilation, even if not required     
 make clean     : Remove backup files generated by emacs and vi (*~) and               
                  all generated files (including .o and binary)             
 make doc       : Generate documentation using doxygen (see www.doxygen.org)
 make help      : print help message                                          

-------------------------------------------------------------
 Using a Versioning System such as CVS/Subversion/Cogito/GIT 
-------------------------------------------------------------

Very often, several programers contributes to projects written in C/C++
In that case, the use of a versionning system is a good idea.
There exists several such systems, here are links to web site that explain the basic 
commands of each of them.

 -  CVS: 
      http://ximbiot.com/cvs/cvshome/docs/blandy.html
      http://www.idealx.org/doc/cvs.fr.html 
      http://freealter.org/doc_distrib/cvs-1.11/introduction/cvs-4.html

 - Subversion: 
      http://svnbook.red-bean.com/
      http://helpdesk.gforge.uni.lu/svn.html

 - Cogito/GIT
      http://www.kernel.org/pub/software/scm/cogito/README
      http://linux.yyz.us/git-howto.html
      http://www.rockfloat.com/howto/git.html

EOF
}

createREADMEFor_multi_c()   { 
    createREADMEHeader
    cat >> README <<EOF
---------------
 Prerequisite 
---------------

Compilation of the files contained in this directory requires the
following binary : 
- gcc 	 (for compilation)
Please check that this command is available on your system. 

This program  can be compiled using the GNU Make utility.
Documentation on the Make utility may be found at 
              http://www.gnu.org/software/make/manual/make.html  
---------
 Install
---------

Just type 'make' in a terminal. 
The binaries generated (one per source file) will be placed in the current directory 

-----------
 Uninstall
-----------
Just run 'make clean'

--------------------
 Detailled Commands 
--------------------

 make           : Compile files, binaries are placed in the current directory
 make force     : Force the complete re-compilation, even if not required     
 make clean     : Remove backup files generated by emacs and vi (*~) and               
                  all generated files             
EOF
}

createREADMEFor_multi_cpp() { createREADMEFor_multi_c; }
################################################################################
#                                      Java                                    #
################################################################################
###
# Create a Makefile for Java project 
##
createMakefileFor_java() {
    createMakefileHeader
    cat >> Makefile << "EOF"
# Compilation of files written in Java
#  each source file generate a class file 
#
# A more complete example: http://comsci.liu.edu/~league/dist/rngzip/trunk/Makefile
# 
# Available Commands  
# ------------------
# make           : Compile files, class files are generated in the current directory  
# make force     : Force the complete re-compilation, even if not needed 
# make clean     : Remove backup files (*~) and other generated files        
#
############################## Variables Declarations ##############################

JAVAC       = javac
JAVACFLAGS  = -Xlint:all 

SRC = $(wildcard *.java)
TARGET = $(SRC:.java=.class)

all: $(TARGET)

%.class: %.java
	$(JAVAC) $(JAVACFLAGS) $^

force:
	touch $(SRC)
	@$(MAKE)

clean: 
	@echo "=> remove binaries and backup files generated by emacs/vi"
	@rm -f $(TARGET) *~

EOF
}

createREADMEFor_java()   { 
    createREADMEHeader
    cat >> README <<EOF
---------------
 Prerequisite 
---------------

Compilation of the files contained in this directory requires the
following binary : 
- javac 	 (for compilation)
Please check that this command is available on your system. 

This program  can be compiled using the GNU Make utility.
Documentation on the Make utility may be found at 
              http://www.gnu.org/software/make/manual/make.html  
---------
 Install
---------

Just type 'make' in a terminal. 
The class files generated (one per source file) will be placed in the current directory 

-----------
 Uninstall
-----------
Just run 'make clean'

--------------------
 Detailled Commands 
--------------------

 make           : Compile java files, class files are placed in the current directory
 make force     : Force the complete re-compilation, even if not required     
 make clean     : Remove backup files generated by emacs and vi (*~) and               
                  all generated files             
EOF
}

################################################################################
#                                      WML                                     #
################################################################################

###
# Create a Makefile for WML project 
##
createMakefileFor_wml() {
    createMakefileHeader
    cat >> Makefile << "EOF"
# Compilation of files written using WML - Website Meta Language 
#
# Documentation on the WML may be found at http://www.thewml.org
# 
# Available Commands  
# ------------------
# make           : Compile files, binary is generated in the current directory  
# make force     : Force the complete re-compilation, even if not needed 
# make rsync     : Synchronize web files on the web server (using rsync+ssh)
# make clean     : Remove backup files generated by emacs and vi         
# make help      : print help message                                          
#
############################## Variables Declarations ##############################

WMK = wmk

# sources
SRC          = $(wildcard *.wml)
DIR          = 
INCLUDE_SRC  = $(shell find . -mindepth 2 -name '*.wml')
INCLUDE_TAG  = $(shell find . -mindepth 2 -name '*.tag')
BACKUP_FILES = $(shell find . -name  '*~')
TARGET       = $(SRC:.wml=.en.html) $(SRC:.wml=.fr.html) $(SRC:.wml=.html)

DEFAULT_LANG = en

MAKEFILE_DEP = .Makefile.dep
SCRIPT_DEPENDANCES = .dependances.sh

# rsync stuff on the gforge
USER=$(shell whoami)
GFORGE_PROJECT=myproject
EXCLUDE_FROM_RSYNC=".svn  Makefile* *~ *.tag *.wml .wmkrc .wmlrc"  # item that should NOT be rsynced space separated.
RSYNC_MODE="--delete"             # use --delete to delete remote files not present

GFORGE=gforge.uni.lu
DEST_DIR="/var/lib/gforge/chroot/home/groups/$(GFORGE_PROJECT)/htdocs"
RSYNC_EXCLUDE_CMD=$(EXCLUDE_FROM_RSYNC:%=--exclude=%)
RSYNC_CMD="rsync --rsh=ssh $(RSYNC_EXCLUDE_CMD) -avz --progress $(RSYNC_MODE) . $(USER)@$(GFORGE):$(DEST_DIR)"

all: $(MAKEFILE_DEP) $(TARGET)

$(MAKEFILE_DEP): $(SRC)
	@./$(SCRIPT_DEPENDANCES) $(DEFAULT_LANG)

# incldue dependances
include $(MAKEFILE_DEP)

test:
	@echo "SRC = $(SRC)"
	@echo "DIR = $(DIR)"
	@echo "INCLUDE_SRC = $(INCLUDE_SRC)"
	@echo "TARGET = $(TARGET)"
	@echo "BACKUP_FILES = $(BACKUP_FILES)"
	@echo "RSYNC_EXCLUDE_CMD = $(RSYNC_EXCLUDE_CMD)"
	@echo "RSYNC_CMD = $(RSYNC_CMD)"

# Force re-compilation, even if not required 
force :
	touch $(SRC)
	@$(MAKE)

rsync: ${TARGET}
	@echo "=> running $(RSYNC_CMD)"
	@eval $(RSYNC_CMD)

clean:
	rm -f $(BACKUP_FILES) $(MAKEFILE_DEP) $(TARGET) 
	@for d in `echo $(DIR)`; do \
	   echo "=> $@ files in $$d"; \
	   $(MAKE) -C $$d $@; \
	done; 

# print help message
help :
	@echo '+----------------------------------------------------------------+'
	@echo '|                        Available Commands                      |'
	@echo '+------------+---------------------------------------------------+'
	@echo '| make       | Compile WML files.                                |'
	@echo '| make force | Force re-compilation, even if not needed          |'
	@echo '| make rsync | Synchronize web files on the server (by rsync+ssh)| 
	@echo '| make clean | Remove all generated files                        |'
	@echo '| make help  | Print help message                                |'
	@echo '+------------+---------------------------------------------------+'
EOF

check_for_overwrite .dependances.sh
cat > .dependances.sh << "EOF"
#! /bin/bash
############################################################################################
# File   : .dependances.sh 
# Author : Sebastien VARRETTE <Sebastien.Varrette@uni.lu>
#          (Web page : http://www-id.imag.fr/~svarrett/)
# Creation date : 28 Nov 2008
#
# Description : see the print_help function or launch '.dependances.sh --help'
#  
# This program is free software; you can redistribute it and/or modify it under the terms 
# of the GNU General Public License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
# See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this 
# program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, 
# Fifth Floor, Boston, MA  02110-1301, USA.
# 
# Sebastien Varrette <Sebastien.Varrette@uni.lu> 
# University of Luxembourg 
# 6, rue Richard Coudenhove-Kalergi
# L-1359 Luxembourg, LUXEMBOURG
############################################################################################

print_error_and_exit() {
    echo "*** ERROR *** $1"
    exit 1
}

###
# check for file inclusion in a wml file
# usage: find_include_files file.wml
##
find_include_files() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] missing command argument"
    cat $1 | grep "#include" | sed -e "s/.*(ROOTREL)\/\(.*\)>/\.\/\1/" | xargs echo
}

MAKEFILE_DEP=.Makefile.dep
MAIN_WML=./include/main.wml
DEFAULT_LANG=en
[ $# -ge 1 ] && DEFAULT_LANG=$1

[ ! -f ${MAIN_WML} ] && print_error_and_exit "${MAIN_WML} not found"
DEFAULT_INCLUDES=`find_include_files ${MAIN_WML}`

# erase ${MAKEFILE_DEP}
echo "" > ${MAKEFILE_DEP}

for src in `ls *.wml | xargs echo`; do
    dest="${src/.wml/.en.html} ${src/.wml/.fr.html} ${src/.wml/.html}"
    link_src="${src/.wml/.${DEFAULT_LANG}.html}"
    link_dst="${src/.wml/.html}"
    includes=`cat $src | grep "#include" | sed -e "s/.*(ROOTREL)\/\(.*\)>/\.\/\1/" | xargs echo`
    echo "$dest : $src $includes ${DEFAULT_INCLUDES}" >> ${MAKEFILE_DEP}
    echo -e "\t@echo -e \"=> [$src] generating $dest\"" >> ${MAKEFILE_DEP}
    echo -e "\t@wml $src" >> ${MAKEFILE_DEP}
    echo -e "\t@ln -sf $link_src $link_dst" >> ${MAKEFILE_DEP}
    echo "" >> ${MAKEFILE_DEP}
done
EOF
}

createREADMEFor_wml() {
    createREADMEHeader
    cat >> README <<EOF
---------------
 Prerequisite 
---------------

Compilation of the files contained in this directory requires the
following binaries : 
- wmk and wml 	 (for compilation)
  which depends on m3 and perl.
Please check that these commands are available on your system. 
  
---------
 Install
---------

Just type 'make' in a terminal. 
Configure the Makefile so that 'make rsync' to be able to synchronize your web site 
on the server using rsync (this assumes an ssh connection to the server)

-----------
 Uninstall
-----------
Just run 'make clean

--------------------
 Detailled Commands 
--------------------

 make           : Compile files, binary is placed in the current directory
 make force     : Force the complete re-compilation, even if not required     
 make rsync     : synchronise local web files on a web server using rsync+ssh
 make clean     : Remove backup files generated by emacs and vi (*~) and               
                  all generated files (including .o and binary)             
 make help      : print help message                                          
EOF
}

###
# Create a directory
# usage: createDir directory
##
createDir() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] a directory is missing as argument"
    local dir=$1
    local check_option=`echo $dir | grep -e '^-'`
    [ ! -z $check_option ] && print_error_and_exit "[$FUNCNAME] $dir : invalid directory"
    # check if it's an absolute path
    local path=`echo $1 | grep -e '^/'`
    [ -z $path ] && path="./$1"
    if [ ! -d $path ]; then
	really_continue "You are about to create the following directory: $path\n"
	echo -n -e "=> creating $path \t";
	execute "mkdir -p $path"
	[ "$?" -ne "0" ] && print_failed || print_ok
    else
	verbose "The directory $path already exists"
    fi
    execute "cd $path"
}

###
# remove a project i.e files specially created for the project + directory (if empty)
# usage: removeProject <files> <dirs_with_makefile> <dirs_without_makefile> 
##
removeProject() {
    [ $# -ne 3 ] && print_error_and_exit "[$FUNCNAME] missing argument"
    tmp=`ls $1 $2 $3 2>/dev/null`
    [ "$?" -ne "0" ] && print_error_and_exit "Nothing to be deleted"
    local files_to_remove=$1
    local subdir_with_makefile=$2
    local subdir_without_makefile=$3
    debug "Files to remove: $files_to_remove"
    debug "Dirs to remove (if empty): $subdir_with_makefile and $subdir_without_makefile"
    local msgdir=""
    [ -n "$2$3" ] && msgdir="and the directories $subdir_with_makefile $subdir_without_makefile (if empty)"
    really_continue "You are about to ${COLOR_BOLD}remove${COLOR_BACK} the files ${COLOR_BOLD}$files_to_remove${COLOR_BACK} $msgdir\n"
    for f in $files_to_remove; do 
	execute "rm -f $f"
    done 
    for d in $subdir_with_makefile; do 
	if [ -f "$d/Makefile" ]; then 
	    execute "rm -f $d/Makefile"
	fi
    done 
    for d in $subdir_with_makefile $subdir_without_makefile; do 
	[  "$(ls -A $d)" ] && \
	    error "the directory $d is not empty and therefore NOT removed" || \
	    execute "rmdir $d"
    done 
}

###
# initiate a project of type $1
##
setupProject() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] missing argument"
    local type=$1
    local files_to_create="Makefile README"
    local subdir_with_makefile=""
    local subdir_without_makefile=""
    case $type in 
	c | cpp |c++) 
                 type="c_cpp";
	         subdir_without_makefile=".obj";;
	beamer | latex)   
	         subdir_with_makefile="Images";
	         subdir_without_makefile=".Trash";;
	wml)     files_to_create="$files_to_create .dependances.sh";;
	multi_c | multi_cpp | java) ;;
	*)       print_error_and_exit "Unknown type"
    esac
    if [ -n "${DELETE_MODE}" ]; then
	removeProject "$files_to_create" "$subdir_with_makefile" "$subdir_without_makefile"
	exit 0;
    fi
    local dir_to_create="$subdir_without_makefile $subdir_with_makefile"
    debug "files to create: $files_to_create"
    debug "directory to create: $dir_to_create"
    local msgdir=""
    [ -n "$subdir_with_makefile$subdir_without_makefile" ] && msgdir="and the following directory: ${COLOR_BOLD}$subdir_with_makefile $subdir_without_makefile${COLOR_BACK} (if empty)"
    really_continue "You are about to ${COLOR_BOLD}create${COLOR_BACK} the files ${COLOR_BOLD}$files_to_create${COLOR_BACK} $msgdir\n"
    if [ -z "${SIMULATION}" ]; then  
	createMakefileFor_$type
	createREADMEFor_$type
    else 
	echo "(simulation) create Makefile and README files"
    fi
    for d in $subdir_without_makefile; do 
	[ ! -d $d ] && execute "mkdir $d";
    done
    for d in $subdir_with_makefile; do 
	[ ! -d $d ] && execute "mkdir $d";
	check_for_overwrite "$d/Makefile"
	execute "cd $d";
	createMakefileInSubdir $d;
	execute "cd -";
    done
    [ "$type" == "beamer" ] && proceedAdditionnalFiles "${BEAMER_ADDITIONAL_FILES_TGZ}"
}

################################################################################
################################################################################

# Check for required argument
[ $# -eq 0 ] && print_error_and_exit

# Check for options
while [ $# -ge 1 ]; do
    case $1 in
	-h | --help)      print_help;        exit 0;;
	-V | --version)   print_version;     exit 0;;
	--debug)          DEBUG="--debug"; 
	                  VERBOSE="--verbose";;
 	-d | --directory) shift;
	                  DIR_TO_CREATE=$1;;
	-r | --remove)    DELETE_MODE="--delete";;
 	-s | --dry-run)   SIMULATION="--dry-run";;
	-v | --verbose)   VERBOSE="--verbose";; 
	*) TYPE=$1;;
    esac
    shift
done

[ -n "${DIR_TO_CREATE}" ] && createDir ${DIR_TO_CREATE}
setupProject ${TYPE}
